***********************
*		  	  	  	  *
*     xthpj           *
*		      	      *
***********************

*! Version 3.0 Ryan Thombs 12/1/25








********************************************************************************
			* Set up program and get basic things for later	*
********************************************************************************
	
		capture program drop xthpj
	
	
		program define xthpj, eclass sortpreserve

		syntax varlist(num ts fv) [if] [in] [ , Absorb(str) lr(str) ecm RESidual(name) savefe]

		
		
		marksample touse
		

		fvexpand `lr'
		loc lr `r(varlist)'

		
		loc varlist `varlist' `lr'
		
		
		gettoken depvar indepvars: varlist 
		

			
		local iv_n : word count `indepvars'
		if `iv_n' == 0 {
			display as error "At least one independent variable must be included in the varlist."
			exit 198
		}

		
		qui cap xtset
		
		if "`r(panelvar)'" == "" | "`r(timevar)'" == "" {
			display as error "The data must be xtset."
			exit 198
		}
		
		loc id 	 = r(panelvar)	// get macros for later
		loc time = r(timevar)

		
		
		
		if "`lr'" != ""       {
		
		tsrevar `lr', list			// get base for LR effects
		loc base "`r(varlist)'"
		loc dve = subinstr("`depvar'", "D.", "", .) // grab DV 
			foreach v of local base {
				if strmatch("`v'","`dve'") == 0 loc base_iv `base_iv' `v'
		}

		

		//names for matrices if LR effects needed
		foreach v of local indepvars {
			loc sr_n `sr_n' SR:`v'
		}
		
		foreach v of local base_iv {
			loc lr_n `lr_n' LR:`v'
		}
		
		loc lr_mname `sr_n' `lr_n'
	
		}

		
		
		
		
********************************************************************************	
	* Get sample used by reghdfe and make sure each panel has even # of obs. *
********************************************************************************
	
		tempvar check checkobs odd first eventot half n sampleA sampleB sampleT asamp testa bsamp testb checka checkb fcheck

		qui reghdfe `varlist' if `touse', absorb(`absorb') 
		
		qui gen `check'					= 1 if e(sample) 										 // get sample generated by reghdfe 

		
		qui by `id': egen `checkobs'	= count(`check') 										 // count number of observations used
		
		
		qui by `id': gen `odd' 			= mod(`checkobs',2) 									 // odd=1 if count is odd
		
		qui by `id': gen `n' 			= sum(`check')
		qui by `id': replace `n' 		= `n' - 1 if `odd' == 1
		qui by `id': replace `n' 		= 0 if `n' < 0


		qui by `id': egen `eventot' 	= count(`check') if `n' > 0 						   	 // # of obs per panel 
		qui by `id': gen `half'	 		= `eventot'/2											 // split sample 

		
		qui by `id': gen byte `sampleA' = 1 if `n' <= `half' & `check' != .						 // 1st half of sample
		qui by `id': replace `sampleA' 	= . if `n' <= 0 & `check' != .
		qui by `id': replace `sampleA' 	= 0 if `sampleA' == . 
		
		qui by `id': gen byte `sampleB' = 1 if `n' > `half' & `check' != .						// 2nd half of sample
		qui by `id': replace `sampleB' 	= 0 if `sampleB' == . 
		
		qui by `id': gen byte `sampleT' = 1 if `sampleA' == 1 | `sampleB' == 1					 // total sample
		qui by `id': replace `sampleT' 	= 0 if `sampleT' == . 									 // e(sample) must be 0/1
		
		
		
		*Check and update sample for singletons
		qui reghdfe `varlist' if `sampleT'==1, absorb(`absorb') noconstant
		qui reghdfe `varlist' if `sampleA'==1, absorb(`absorb') noconstant
		qui gen `asamp' = 1 if e(sample)
		qui by `id': gen `testa' = 1 if `sampleA' != `asamp' & `sampleA'==1
		qui replace `sampleA' = 0 if `testa'==1
		
		qui reghdfe `varlist' if `sampleB'==1, absorb(`absorb') noconstant 
		qui gen `bsamp' = 1 if e(sample)
		qui by `id': gen `testb' = 1 if `sampleB' != `bsamp' & `sampleB'==1
		qui replace `sampleB' = 0 if `testb'==1
		
		qui by `id': egen `checka'	= total(`sampleA') 
		qui by `id': egen `checkb'	= total(`sampleB')
		qui by `id': gen `fcheck'	= `checka'-`checkb'
		
		qui replace `sampleT' = 0 if `fcheck' != 0
		qui replace `sampleT' = 0 if `checka' == 0 | `checkb' == 0
		qui replace `sampleA' = 0 if `fcheck' != 0
		qui replace `sampleB' = 0 if `fcheck' != 0
		
		qui sum `sampleT' if `sampleT'	== 1
		qui scalar F					= `r(N)' 
		
		qui sum `eventot' if `sampleT'	== 1
		qui scalar gmin  				= `r(min)'												 // min T 
		qui scalar gmax  				= `r(max)'												 // max T
		
		qui sum `sampleA' if `sampleA'  == 1
		qui scalar A					= `r(N)'
		
		qui sum `sampleB' if `sampleB'  == 1
		qui scalar B					= `r(N)'  
		

		
********************************************************************************	 
		  * Partial Out FEs and Save Demeaned Values *
********************************************************************************	 
		
		tempvar d da db
		
		loc i 1
		
		foreach x in `varlist' {
			loc `d'`i'	
			loc dT "`dT' `d'`i'"
			loc `da'`i'	
			loc dA "`dA' `da'`i'"
			loc `db'`i'	
			loc dB "`dB' `db'`i'"
			loc ++i
		}
		


		
		* Full Sample 
		
        cap which reghdfe
        loc rc = _rc
        cap which ftools
        if _rc | `rc' {                                 
                di as err "option {it: absorb()} requires {help:reghdfe} and {help ftools}:"
                di as err "  click {stata ssc install reghdfe} to install from SSC"
                di as err "  click {stata ssc install ftools} to install from SSC"
                exit 199
        }
        cap include "reghdfe.mata", adopath
		
		
		mata: HDFE_T 			= FixedEffects()
		mata: HDFE_T.absvars 	= "`absorb'"
        mata: HDFE_T.tousevar 	= "`sampleT'"
		mata: HDFE_T.verbose 	= -1
		mata: HDFE_T.init()
        mata: HDFE_T.partial_out("`depvar' `indepvars'", 1, 0)
		mata: st_store(HDFE_T.sample, st_addvar("double", tokens("`dT'")), HDFE_T.solution.data)
		

		* 1st Half Sample 
		
		mata: HDFE_A 			= FixedEffects()
		mata: HDFE_A.absvars 	= "`absorb'"
        mata: HDFE_A.tousevar 	= "`sampleA'"
		mata: HDFE_A.verbose 	= -1
		mata: HDFE_A.init()
        mata: HDFE_A.partial_out("`depvar' `indepvars'", 1, 0)
		mata: st_store(HDFE_A.sample, st_addvar("double", tokens("`dA'")), HDFE_A.solution.data)
		
		
		* 2nd Half Sample 
		
		mata: HDFE_B 			= FixedEffects()
		mata: HDFE_B.absvars 	= "`absorb'"
        mata: HDFE_B.tousevar 	= "`sampleB'"
		mata: HDFE_B.verbose 	= -1
		mata: HDFE_B.init()
        mata: HDFE_B.partial_out("`depvar' `indepvars'", 1, 0)
		mata: st_store(HDFE_B.sample, st_addvar("double", tokens("`dB'")), HDFE_B.solution.data)

		* Get d*_it for variance-covariance matrix (CPY, p. 823)

		local n : word count `dT'
		tempvar dit 

		forvalues i = 1/`n' {
			local a : word `i' of `dT'
			local b : word `i' of `dA'
			local c : word `i' of `dB'
			gen `dit'`i' = cond(missing(`a'), 0, 2*`a') - cond(missing(`b'), 0, `b') - cond(missing(`c'), 0, `c')
			local DDV "`DDV' `dit'`i'"
 }
		
			gettoken dit_dv dit_iv : DDV

		
		
********************************************************************************
						* Beta Estimates *
********************************************************************************		
		

	   * Full Sample Estimate 
	   	if "`savefe'" == "savefe" {
			qui reghdfe `varlist' if `sampleT'==1, absorb(`absorb', savefe) noconstant
			mat b0 = e(b)
			
			foreach x of var __hdfe* {
			rename `x' full_`x'
				}
		}
		else {
			qui reghdfe `varlist' if `sampleT'==1, absorb(`absorb') noconstant
			mat b0 = e(b)
		}

	   * 1st Half Sample Estimate 
	   	if "`savefe'" == "savefe" {
			qui reghdfe `varlist' if `sampleA'==1, absorb(`absorb', savefe) noconstant
			mat b1 = e(b)
			
			foreach x of var __hdfe* {
			rename `x' a_`x'
				}
		}
		else {
			qui reghdfe `varlist' if `sampleA'==1, absorb(`absorb') noconstant
			mat b1 = e(b)
		}

	   * 2nd Half Sample Estimate 
	   	if "`savefe'" == "savefe" {
			qui reghdfe `varlist' if `sampleB'==1, absorb(`absorb', savefe) noconstant 
			mat b2 = e(b) 
			
			foreach x of var __hdfe* {
			rename `x' b_`x'
				}
		}
		else {
			qui reghdfe `varlist' if `sampleB'==1, absorb(`absorb') noconstant 
			mat b2 = e(b) 
		}
	   

		
	   * Jackknife Estimate 	
	   	mat b = 2*b0 - .5*b1 - .5*b2

	 	

		
********************************************************************************
				* Variance-Covariance Matrix *
********************************************************************************
	
	
		gettoken d_dv d_iv : dT
		
		loc vce = 0
		
		if "`residual'" != "" {
			loc ryes = 1
			loc residn = "`residual'"
		}
		else {
			loc ryes = 0
			loc residn = ""
		}
		
		
			
		mata: vce_hpj("`d_dv'", "`d_iv'", "`dit_iv'", "`sampleT'", "b", "`vce'", "`id'", "`ryes'", "`residn'")	
		


		
********************************************************************************
				* Column and Row Names for Matricies *
********************************************************************************


		loc betas b b0 b1 b2
		
		foreach b of loc betas {
			
			if "`lr'" != "" {
				matrix coln `b'		= SR:
				}
				
			matrix coln `b'  		= `indepvars'
			matrix rown `b'  		= `depvar'
			
		}
		
		if "`lr'" != "" {
			matrix coln V			= SR:
			matrix rown V			= SR:
		}
		
		mat coln V 				= `indepvars'
		mat rown V 				= `indepvars'
		
		
		
		

	
********************************************************************************
				* Additional Info to Report with Results *
********************************************************************************
		
		tempvar N T NT avgT res2
		
		qui xtsum `sampleT' if `sampleT'==1
		qui scalar `N' 		= `r(n)'
		qui scalar `T' 		= `r(Tbar)'
		qui scalar `NT' 	= `N'*`T' 
		qui scalar `avgT'	= `NT'/`N'
		loc fe_n : word count `absorb'
		
		
		if "`lr'" == "" {
				eret post b V, depname(`depvar') buildfvinfo findomitted esample(`sampleT')	
		}
		
		
		
		
********************************************************************************
				* Long-Run Effects *
********************************************************************************
		
	
	if "`lr'" != "" {
		
		eret post b V
		
		foreach v of local indepvars {
			loc sr_eff `sr_eff' (_b[`v'])
		}
	
	if "`ecm'" == "" {
	   	
	*capture independent variables of interest
		foreach j of local base_iv { 
			foreach v of local lr {
				if strmatch("`v'","`j'") == 1 | strmatch("`v'","L*.`j'") == 1 | strmatch("`v'","l*.`j'") == 1 | strmatch("`v'","L*D.`j'") == 1 | ///
				strmatch("`v'","L*d.`j'") == 1 | strmatch("`v'","l*D.`j'") == 1 | strmatch("`v'","l*d.`j'") == 1 local i_`j' `i_`j'' _b[`v'] 
				loc i_`j' = subinstr("`i_`j''", " ", "+", .)
				}
			}

  
	* capture dependent variable 
		foreach v of local lr {
			if strmatch("`v'","l*.`dve'") == 1 | strmatch("`v'","L*.`dve'") == 1 | strmatch("`v'","Ld*.`dve'") == 1 | strmatch("`v'","LD*.`dve'") == 1 | ///
			strmatch("`v'","ld*.`dve'") == 1 | strmatch("`v'","lD*.`dve'") == 1 local d_`dve' `d_`dve'' _b[`v'] 
			loc d_`dve' = subinstr("`d_`dve''", " ", "-", .)
		}
  

	// local containing ARDL LR estimate
		foreach v of local base_iv {
			loc lr_eff `lr_eff' (`v' : (`i_`v'')/(1-`d_`dve''))
	}	
	}
	
	
	if "`ecm'" != "" {
	
	*capture independent variables of interest
		foreach j of local base_iv { 
			foreach v of local lr {
				if strmatch("`v'","L*.`j'") == 1 | strmatch("`v'","l*.`j'") == 1 & strmatch("`v'","`j'") == 0 & strmatch("`v'","L*D.`j'") == 0 & ///
				strmatch("`v'","L*d.`j'") == 0 & strmatch("`v'","l*D.`j'") == 0 & strmatch("`v'","l*d.`j'") == 0 local i_`j' `i_`j'' _b[`v'] 
				loc i_`j' = subinstr("`i_`j''", " ", "+", .)
				}
			}

  
	* capture dependent variable 
		foreach v of local lr {
			if strmatch("`v'","l*.`dve'") == 1 | strmatch("`v'","L*.`dve'") == 1 & strmatch("`v'","Ld*.`dve'") == 0 & strmatch("`v'","LD*.`dve'") == 0 & ///
			strmatch("`v'","ld*.`dve'") == 0 & strmatch("`v'","lD*.`dve'") == 0 local d_`dve' `d_`dve'' _b[`v'] 
			loc d_`dve' = subinstr("`d_`dve''", " ", "+", .)
		}
  

	// local containing ECM LR estimate
		foreach v of local base_iv {
			loc lr_eff `lr_eff' (`v' : -(`i_`v'')/(`d_`dve''))
	}	
	}
	
	
		qui nlcom `sr_eff' `lr_eff'


		mat b_lr = r(b)
		mat V_lr = r(V)
		

		matrix coln b_lr		= `lr_mname'
		matrix rown b_lr  		= y1

	   	 
		matrix coln V_lr  		= `lr_mname'
		matrix rown V_lr  		= `lr_mname'
		
	   
		mat b = b_lr
		mat V = V_lr

	
 
	   eret clear 
	   eret post b V, depname(`depvar') buildfvinfo findomitted esample(`sampleT')	

	  } 

	   



		
********************************************************************************
					* Display Estimation Results *
********************************************************************************
 		



		// macros, scalars, matricies 
		
		eret loc cmdline		`"xthpj `0'"'
		eret loc cmd			"xthpj"
		eret loc ivar 			"`id'"
		eret loc time 			"`time'"
		
		eret loc absorb 		"`absorb'"
		

		eret scalar N_full 			 	= F
		eret scalar N_a					= A
		eret scalar N_b					= B
		eret scalar N_g			 		= `N'
		eret scalar T_min		 		= gmin 
		eret scalar T_avg		 		= `avgT'
		eret scalar T_max		 		= gmax 
		
		
		eret mat b_full	 				= b0 
		eret mat b_a	 				= b1 
		eret mat b_b 					= b2 
		
		eret hidden loc depvar "`depvar'"
		eret hidden loc indepvars "`indepvars'"
		
		
		// table header 
		
		di _newline as txt "Half-Panel Jackknife HDFE Regression" 		
		di as txt "Absorbing `fe_n' HDFE groups" _column(46) as txt "Number of obs" _col(68) "=" _col(70) as res %9.0g `NT'
		di as txt _column(46) as txt "Number of groups" _col(68) "=" _col(70) as res %9.0g `N' _newline
		di _column(46) as txt "Obs per group:"
		di _column(60) as txt "min" _col(68) "=" _col(70) as res %9.0fc gmin
		di _column(60) as txt "avg" _col(68) "=" _col(70) as res %9.1fc `avgT'
		di _column(60) as txt "max" _col(68) "=" _col(70) as res %9.0fc gmax

		// coefficient table, returns r(table) too
		

		_coef_table
		


	  	   
end 





capture mata mata drop vce_hpj()
mata: 
function vce_hpj( string scalar depvar,  string scalar indepvars, 
			  string scalar dit, 	 string scalar touse, 
			  string scalar bname,	 string scalar vcetype,
			  string scalar id,      string scalar ryes,
			  string scalar residn) 
{

	real vector y, e, e2, b, cvar, info
	real matrix X, X2, XpX, XpXi, M, V, xi, ei, xiei, resi, res, yi
	real scalar n, p, k, nc, i, idx 

	
		y		= st_data(., depvar, touse)
		X  		= st_data(., indepvars, touse)
		X2		= st_data(., dit, touse)

		b  		= st_matrix(bname)
		XpX  	= quadcross(X, X)
		XpXi 	= invsym(XpX)
		
		n    	= rows(X)
		p    	= cols(X)
		k    	= p - diag0cnt(XpXi)
		e  		= y - X*b'
		e2 		= e:^2
		
		
		
		// Generate residual if wanted 

		if (ryes == "1") {
		idx = st_addvar("double", residn)
	    st_view(res,.,residn,touse)
		
		cvar = st_data(., id, touse)
		info = panelsetup(cvar, 1)
		i = rows(info)
                while (i>0) {
                        yi = panelsubmatrix(y,i,info)
                        xi = panelsubmatrix(X,i,info)
                        panelsubview(resi,res,i,info)

                        resi[.,.] = yi - xi * b'
                        
                        i--
                }
		}

		
		
		if (vcetype == "0") {
			M    	= quadcross(X2, e2, X2)
			V 		= XpXi*M*XpXi
		}
		
		
		st_matrix("V", V)

}
end














